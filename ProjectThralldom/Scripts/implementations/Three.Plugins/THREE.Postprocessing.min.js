THREE.BasicShader={uniforms:{},vertexShader:"void main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"void main() {\ngl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );\n}"};THREE.BleachBypassShader={uniforms:{tDiffuse:{type:"t",value:null},opacity:{type:"f",value:1}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float opacity;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 base = texture2D( tDiffuse, vUv );\nvec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );\nfloat lum = dot( lumCoeff, base.rgb );\nvec3 blend = vec3( lum );\nfloat L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );\nvec3 result1 = 2.0 * base.rgb * blend;\nvec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );\nvec3 newColor = mix( result1, result2, L );\nfloat A2 = opacity * base.a;\nvec3 mixRGB = A2 * newColor.rgb;\nmixRGB += ( ( 1.0 - A2 ) * base.rgb );\ngl_FragColor = vec4( mixRGB, base.a );\n}"};THREE.BlendShader={uniforms:{tDiffuse1:{type:"t",value:null},tDiffuse2:{type:"t",value:null},mixRatio:{type:"f",value:.5},opacity:{type:"f",value:1}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float opacity;\nuniform float mixRatio;\nuniform sampler2D tDiffuse1;\nuniform sampler2D tDiffuse2;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel1 = texture2D( tDiffuse1, vUv );\nvec4 texel2 = texture2D( tDiffuse2, vUv );\ngl_FragColor = opacity * mix( texel1, texel2, mixRatio );\n}"};THREE.BloomPass=function(n,t,i,r){var e,u,f;n=n!==undefined?n:1;t=t!==undefined?t:25;i=i!==undefined?i:4;r=r!==undefined?r:256;e={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat};this.renderTargetX=new THREE.WebGLRenderTarget(r,r,e);this.renderTargetY=new THREE.WebGLRenderTarget(r,r,e);THREE.CopyShader===undefined&&console.error("THREE.BloomPass relies on THREE.CopyShader");u=THREE.CopyShader;this.copyUniforms=THREE.UniformsUtils.clone(u.uniforms);this.copyUniforms.opacity.value=n;this.materialCopy=new THREE.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:u.vertexShader,fragmentShader:u.fragmentShader,blending:THREE.AdditiveBlending,transparent:!0});THREE.ConvolutionShader===undefined&&console.error("THREE.BloomPass relies on THREE.ConvolutionShader");f=THREE.ConvolutionShader;this.convolutionUniforms=THREE.UniformsUtils.clone(f.uniforms);this.convolutionUniforms.uImageIncrement.value=THREE.BloomPass.blurx;this.convolutionUniforms.cKernel.value=THREE.ConvolutionShader.buildKernel(i);this.materialConvolution=new THREE.ShaderMaterial({uniforms:this.convolutionUniforms,vertexShader:f.vertexShader,fragmentShader:f.fragmentShader,defines:{KERNEL_SIZE_FLOAT:t.toFixed(1),KERNEL_SIZE_INT:t.toFixed(0)}});this.enabled=!0;this.needsSwap=!1;this.clear=!1;this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1);this.scene=new THREE.Scene;this.quad=new THREE.Mesh(new THREE.PlaneGeometry(2,2),null);this.scene.add(this.quad)};THREE.BloomPass.prototype={render:function(n,t,i,r,u){u&&n.context.disable(n.context.STENCIL_TEST);this.quad.material=this.materialConvolution;this.convolutionUniforms.tDiffuse.value=i;this.convolutionUniforms.uImageIncrement.value=THREE.BloomPass.blurX;n.render(this.scene,this.camera,this.renderTargetX,!0);this.convolutionUniforms.tDiffuse.value=this.renderTargetX;this.convolutionUniforms.uImageIncrement.value=THREE.BloomPass.blurY;n.render(this.scene,this.camera,this.renderTargetY,!0);this.quad.material=this.materialCopy;this.copyUniforms.tDiffuse.value=this.renderTargetY;u&&n.context.enable(n.context.STENCIL_TEST);n.render(this.scene,this.camera,i,this.clear)}};THREE.BloomPass.blurX=new THREE.Vector2(.001953125,0);THREE.BloomPass.blurY=new THREE.Vector2(0,.001953125);THREE.BokehPass=function(n,t,i){var u,r;this.scene=n;this.camera=t;var f=i.focus!==undefined?i.focus:1,e=i.aspect!==undefined?i.aspect:t.aspect,o=i.aperture!==undefined?i.aperture:.025,s=i.maxblur!==undefined?i.maxblur:1,h=i.width||window.innerWidth||1,c=i.height||window.innerHeight||1;this.renderTargetColor=new THREE.WebGLRenderTarget(h,c,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat});this.renderTargetDepth=this.renderTargetColor.clone();this.materialDepth=new THREE.MeshDepthMaterial;THREE.BokehShader===undefined&&console.error("THREE.BokehPass relies on THREE.BokehShader");u=THREE.BokehShader;r=THREE.UniformsUtils.clone(u.uniforms);r.tDepth.value=this.renderTargetDepth;r.focus.value=f;r.aspect.value=e;r.aperture.value=o;r.maxblur.value=s;this.materialBokeh=new THREE.ShaderMaterial({uniforms:r,vertexShader:u.vertexShader,fragmentShader:u.fragmentShader});this.uniforms=r;this.enabled=!0;this.needsSwap=!1;this.renderToScreen=!1;this.clear=!1;this.camera2=new THREE.OrthographicCamera(-1,1,1,-1,0,1);this.scene2=new THREE.Scene;this.quad2=new THREE.Mesh(new THREE.PlaneGeometry(2,2),null);this.scene2.add(this.quad2)};THREE.BokehPass.prototype={render:function(n,t,i){this.quad2.material=this.materialBokeh;this.scene.overrideMaterial=this.materialDepth;n.render(this.scene,this.camera,this.renderTargetDepth,!0);this.uniforms.tColor.value=i;this.renderToScreen?n.render(this.scene2,this.camera2):n.render(this.scene2,this.camera2,t,this.clear);this.scene.overrideMaterial=null}};THREE.BokehShader={uniforms:{tColor:{type:"t",value:null},tDepth:{type:"t",value:null},focus:{type:"f",value:1},aspect:{type:"f",value:1},aperture:{type:"f",value:.025},maxblur:{type:"f",value:1}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"varying vec2 vUv;\nuniform sampler2D tColor;\nuniform sampler2D tDepth;\nuniform float maxblur;\nuniform float aperture;\nuniform float focus;\nuniform float aspect;\nvoid main() {\nvec2 aspectcorrect = vec2( 1.0, aspect );\nvec4 depth1 = texture2D( tDepth, vUv );\nfloat factor = depth1.x - focus;\nvec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\nvec2 dofblur9 = dofblur * 0.9;\nvec2 dofblur7 = dofblur * 0.7;\nvec2 dofblur4 = dofblur * 0.4;\nvec4 col = vec4( 0.0 );\ncol += texture2D( tColor, vUv.xy );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\ncol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\ncol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\ngl_FragColor = col / 41.0;\ngl_FragColor.a = 1.0;\n}"};THREE.BokehShader={uniforms:{textureWidth:{type:"f",value:1},textureHeight:{type:"f",value:1},focalDepth:{type:"f",value:1},focalLength:{type:"f",value:24},fstop:{type:"f",value:.9},tColor:{type:"t",value:null},tDepth:{type:"t",value:null},maxblur:{type:"f",value:1},showFocus:{type:"i",value:0},manualdof:{type:"i",value:0},vignetting:{type:"i",value:0},depthblur:{type:"i",value:0},threshold:{type:"f",value:.5},gain:{type:"f",value:2},bias:{type:"f",value:.5},fringe:{type:"f",value:.7},znear:{type:"f",value:.1},zfar:{type:"f",value:100},noise:{type:"i",value:1},dithering:{type:"f",value:.0001},pentagon:{type:"i",value:0},shaderFocus:{type:"i",value:1},focusCoords:{type:"v2",value:new THREE.Vector2}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"varying vec2 vUv;\nuniform sampler2D tColor;\nuniform sampler2D tDepth;\nuniform float textureWidth;\nuniform float textureHeight;\nconst float PI = 3.14159265;\nfloat width = textureWidth; //texture width\nfloat height = textureHeight; //texture height\nvec2 texel = vec2(1.0/width,1.0/height);\nuniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\nuniform float focalLength; //focal length in mm\nuniform float fstop; //f-stop value\nuniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\n/*\nmake sure that these two values are the same for your camera, otherwise distances will be wrong.\n*/\nuniform float znear; // camera clipping start\nuniform float zfar; // camera clipping end\n//------------------------------------------\n//user variables\nconst int samples = SAMPLES; //samples on the first ring\nconst int rings = RINGS; //ring count\nconst int maxringsamples = rings * samples;\nuniform bool manualdof; // manual dof calculation\nfloat ndofstart = 1.0; // near dof blur start\nfloat ndofdist = 2.0; // near dof blur falloff distance\nfloat fdofstart = 1.0; // far dof blur start\nfloat fdofdist = 3.0; // far dof blur falloff distance\nfloat CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\nuniform bool vignetting; // use optical lens vignetting\nfloat vignout = 1.3; // vignetting outer border\nfloat vignin = 0.0; // vignetting inner border\nfloat vignfade = 22.0; // f-stops till vignete fades\nuniform bool shaderFocus;\nbool autofocus = shaderFocus;\n//use autofocus in shader - use with focusCoords\n// disable if you use external focalDepth value\nuniform vec2 focusCoords;\n// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\n// if center of screen use vec2(0.5, 0.5);\nuniform float maxblur;\n//clamp value of max blur (0.0 = no blur, 1.0 default)\nuniform float threshold; // highlight threshold;\nuniform float gain; // highlight gain;\nuniform float bias; // bokeh edge bias\nuniform float fringe; // bokeh chromatic aberration / fringing\nuniform bool noise; //use noise instead of pattern for sample dithering\nuniform float dithering;\nfloat namount = dithering; //dither amount\nuniform bool depthblur; // blur the depth buffer\nfloat dbsize = 1.25; // depth blur size\n/*\nnext part is experimental\nnot looking good with small sample and ring count\nlooks okay starting from samples = 4, rings = 4\n*/\nuniform bool pentagon; //use pentagon as bokeh shape?\nfloat feather = 0.4; //pentagon shape feather\n//------------------------------------------\nfloat penta(vec2 coords) {\n//pentagonal shape\nfloat scale = float(rings) - 1.3;\nvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\nvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\nvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\nvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\nvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\nvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\nvec4  one = vec4( 1.0 );\nvec4 P = vec4((coords),vec2(scale, scale));\nvec4 dist = vec4(0.0);\nfloat inorout = -4.0;\ndist.x = dot( P, HS0 );\ndist.y = dot( P, HS1 );\ndist.z = dot( P, HS2 );\ndist.w = dot( P, HS3 );\ndist = smoothstep( -feather, feather, dist );\ninorout += dot( dist, one );\ndist.x = dot( P, HS4 );\ndist.y = HS5.w - abs( P.z );\ndist = smoothstep( -feather, feather, dist );\ninorout += dist.x;\nreturn clamp( inorout, 0.0, 1.0 );\n}\nfloat bdepth(vec2 coords) {\n// Depth buffer blur\nfloat d = 0.0;\nfloat kernel[9];\nvec2 offset[9];\nvec2 wh = vec2(texel.x, texel.y) * dbsize;\noffset[0] = vec2(-wh.x,-wh.y);\noffset[1] = vec2( 0.0, -wh.y);\noffset[2] = vec2( wh.x -wh.y);\noffset[3] = vec2(-wh.x,  0.0);\noffset[4] = vec2( 0.0,   0.0);\noffset[5] = vec2( wh.x,  0.0);\noffset[6] = vec2(-wh.x, wh.y);\noffset[7] = vec2( 0.0,  wh.y);\noffset[8] = vec2( wh.x, wh.y);\nkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\nkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\nkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\nfor( int i=0; i<9; i++ ) {\nfloat tmp = texture2D(tDepth, coords + offset[i]).r;\nd += tmp * kernel[i];\n}\nreturn d;\n}\nvec3 color(vec2 coords,float blur) {\n//processing the sample\nvec3 col = vec3(0.0);\ncol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\ncol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\ncol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\nvec3 lumcoeff = vec3(0.299,0.587,0.114);\nfloat lum = dot(col.rgb, lumcoeff);\nfloat thresh = max((lum-threshold)*gain, 0.0);\nreturn col+mix(vec3(0.0),col,thresh*blur);\n}\nvec2 rand(vec2 coord) {\n// generating noise / pattern texture for dithering\nfloat noiseX = ((fract(1.0-coord.s*(width/2.0))*0.25)+(fract(coord.t*(height/2.0))*0.75))*2.0-1.0;\nfloat noiseY = ((fract(1.0-coord.s*(width/2.0))*0.75)+(fract(coord.t*(height/2.0))*0.25))*2.0-1.0;\nif (noise) {\nnoiseX = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;\nnoiseY = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;\n}\nreturn vec2(noiseX,noiseY);\n}\nvec3 debugFocus(vec3 col, float blur, float depth) {\nfloat edge = 0.002*depth; //distance based edge smoothing\nfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\nfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\ncol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\ncol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\nreturn col;\n}\nfloat linearize(float depth) {\nreturn -zfar * znear / (depth * (zfar - znear) - zfar);\n}\nfloat vignette() {\nfloat dist = distance(vUv.xy, vec2(0.5,0.5));\ndist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\nreturn clamp(dist,0.0,1.0);\n}\nfloat gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\nfloat rings2 = float(rings);\nfloat step = PI*2.0 / float(ringsamples);\nfloat pw = cos(j*step)*i;\nfloat ph = sin(j*step)*i;\nfloat p = 1.0;\nif (pentagon) {\np = penta(vec2(pw,ph));\n}\ncol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\nreturn 1.0 * mix(1.0, i /rings2, bias) * p;\n}\nvoid main() {\n//scene depth calculation\nfloat depth = linearize(texture2D(tDepth,vUv.xy).x);\n// Blur depth?\nif (depthblur) {\ndepth = linearize(bdepth(vUv.xy));\n}\n//focal plane calculation\nfloat fDepth = focalDepth;\nif (autofocus) {\nfDepth = linearize(texture2D(tDepth,focusCoords).x);\n}\n// dof blur factor calculation\nfloat blur = 0.0;\nif (manualdof) {\nfloat a = depth-fDepth; // Focal plane\nfloat b = (a-fdofstart)/fdofdist; // Far DoF\nfloat c = (-a-ndofstart)/ndofdist; // Near Dof\nblur = (a>0.0) ? b : c;\n} else {\nfloat f = focalLength; // focal length in mm\nfloat d = fDepth*1000.0; // focal plane in mm\nfloat o = depth*1000.0; // depth in mm\nfloat a = (o*f)/(o-f);\nfloat b = (d*f)/(d-f);\nfloat c = (d-f)/(d*fstop*CoC);\nblur = abs(a-b)*c;\n}\nblur = clamp(blur,0.0,1.0);\n// calculation of pattern for dithering\nvec2 noise = rand(vUv.xy)*namount*blur;\n// getting blur x and y step factor\nfloat w = (1.0/width)*blur*maxblur+noise.x;\nfloat h = (1.0/height)*blur*maxblur+noise.y;\n// calculation of final color\nvec3 col = vec3(0.0);\nif(blur < 0.05) {\n//some optimization thingy\ncol = texture2D(tColor, vUv.xy).rgb;\n} else {\ncol = texture2D(tColor, vUv.xy).rgb;\nfloat s = 1.0;\nint ringsamples;\nfor (int i = 1; i <= rings; i++) {\n/*unboxstart*/\nringsamples = i * samples;\nfor (int j = 0 ; j < maxringsamples ; j++) {\nif (j >= ringsamples) break;\ns += gather(float(i), float(j), ringsamples, col, w, h, blur);\n}\n/*unboxend*/\n}\ncol /= s; //divide by sample count\n}\nif (showFocus) {\ncol = debugFocus(col, blur, depth);\n}\nif (vignetting) {\ncol *= vignette();\n}\ngl_FragColor.rgb = col;\ngl_FragColor.a = 1.0;\n} "};THREE.BrightnessContrastShader={uniforms:{tDiffuse:{type:"t",value:null},brightness:{type:"f",value:0},contrast:{type:"f",value:0}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse;\nuniform float brightness;\nuniform float contrast;\nvarying vec2 vUv;\nvoid main() {\ngl_FragColor = texture2D( tDiffuse, vUv );\ngl_FragColor.rgb += brightness;\nif (contrast > 0.0) {\ngl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;\n} else {\ngl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;\n}\n}"};THREE.ColorCorrectionShader={uniforms:{tDiffuse:{type:"t",value:null},powRGB:{type:"v3",value:new THREE.Vector3(2,2,2)},mulRGB:{type:"v3",value:new THREE.Vector3(1,1,1)}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse;\nuniform vec3 powRGB;\nuniform vec3 mulRGB;\nvarying vec2 vUv;\nvoid main() {\ngl_FragColor = texture2D( tDiffuse, vUv );\ngl_FragColor.rgb = mulRGB * pow( gl_FragColor.rgb, powRGB );\n}"};THREE.ColorifyShader={uniforms:{tDiffuse:{type:"t",value:null},color:{type:"c",value:new THREE.Color(16777215)}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform vec3 color;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D( tDiffuse, vUv );\nvec3 luma = vec3( 0.299, 0.587, 0.114 );\nfloat v = dot( texel.xyz, luma );\ngl_FragColor = vec4( v * color, texel.w );\n}"};THREE.ConvolutionShader={defines:{KERNEL_SIZE_FLOAT:"25.0",KERNEL_SIZE_INT:"25"},uniforms:{tDiffuse:{type:"t",value:null},uImageIncrement:{type:"v2",value:new THREE.Vector2(.001953125,0)},cKernel:{type:"fv1",value:[]}},vertexShader:"uniform vec2 uImageIncrement;\nvarying vec2 vUv;\nvoid main() {\nvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float cKernel[ KERNEL_SIZE_INT ];\nuniform sampler2D tDiffuse;\nuniform vec2 uImageIncrement;\nvarying vec2 vUv;\nvoid main() {\nvec2 imageCoord = vUv;\nvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\nfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\nsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\nimageCoord += uImageIncrement;\n}\ngl_FragColor = sum;\n}",buildKernel:function(n){function o(n,t){return Math.exp(-(n*n)/(2*t*t))}var t,r,u,f,e=25,i=2*Math.ceil(n*3)+1;for(i>e&&(i=e),f=(i-1)*.5,r=new Array(i),u=0,t=0;t<i;++t)r[t]=o(t-f,n),u+=r[t];for(t=0;t<i;++t)r[t]/=u;return r}};THREE.CopyShader={uniforms:{tDiffuse:{type:"t",value:null},opacity:{type:"f",value:1}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float opacity;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D( tDiffuse, vUv );\ngl_FragColor = opacity * texel;\n}"};THREE.DOFMipMapShader={uniforms:{tColor:{type:"t",value:null},tDepth:{type:"t",value:null},focus:{type:"f",value:1},maxblur:{type:"f",value:1}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float focus;\nuniform float maxblur;\nuniform sampler2D tColor;\nuniform sampler2D tDepth;\nvarying vec2 vUv;\nvoid main() {\nvec4 depth = texture2D( tDepth, vUv );\nfloat factor = depth.x - focus;\nvec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );\ngl_FragColor = col;\ngl_FragColor.a = 1.0;\n}"};THREE.DotScreenPass=function(n,t,i){THREE.DotScreenShader===undefined&&console.error("THREE.DotScreenPass relies on THREE.DotScreenShader");var r=THREE.DotScreenShader;this.uniforms=THREE.UniformsUtils.clone(r.uniforms);n!==undefined&&this.uniforms.center.value.copy(n);t!==undefined&&(this.uniforms.angle.value=t);i!==undefined&&(this.uniforms.scale.value=i);this.material=new THREE.ShaderMaterial({uniforms:this.uniforms,vertexShader:r.vertexShader,fragmentShader:r.fragmentShader});this.enabled=!0;this.renderToScreen=!1;this.needsSwap=!0;this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1);this.scene=new THREE.Scene;this.quad=new THREE.Mesh(new THREE.PlaneGeometry(2,2),null);this.scene.add(this.quad)};THREE.DotScreenPass.prototype={render:function(n,t,i){this.uniforms.tDiffuse.value=i;this.uniforms.tSize.value.set(i.width,i.height);this.quad.material=this.material;this.renderToScreen?n.render(this.scene,this.camera):n.render(this.scene,this.camera,t,!1)}};THREE.DotScreenShader={uniforms:{tDiffuse:{type:"t",value:null},tSize:{type:"v2",value:new THREE.Vector2(256,256)},center:{type:"v2",value:new THREE.Vector2(.5,.5)},angle:{type:"f",value:1.57},scale:{type:"f",value:1}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform vec2 center;\nuniform float angle;\nuniform float scale;\nuniform vec2 tSize;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nfloat pattern() {\nfloat s = sin( angle ), c = cos( angle );\nvec2 tex = vUv * tSize - center;\nvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\nreturn ( sin( point.x ) * sin( point.y ) ) * 4.0;\n}\nvoid main() {\nvec4 color = texture2D( tDiffuse, vUv );\nfloat average = ( color.r + color.g + color.b ) / 3.0;\ngl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\n}"};THREE.EdgeShader={uniforms:{tDiffuse:{type:"t",value:null},aspect:{type:"v2",value:new THREE.Vector2(512,512)}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:["uniform sampler2D tDiffuse;","varying vec2 vUv;","uniform vec2 aspect;","vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);","mat3 G[9];","const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );","const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );","const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );","const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );","const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );","const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );","const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );","const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );","const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );","void main(void)","{","G[0] = g0,","G[1] = g1,","G[2] = g2,","G[3] = g3,","G[4] = g4,","G[5] = g5,","G[6] = g6,","G[7] = g7,","G[8] = g8;","mat3 I;","float cnv[9];","vec3 sample;","for (float i=0.0; i<3.0; i++) {","for (float j=0.0; j<3.0; j++) {","sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;","I[int(i)][int(j)] = length(sample);","}","}","for (int i=0; i<9; i++) {","float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);","cnv[i] = dp3 * dp3;","}","float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);","float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);","gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);","}",].join("\n")};THREE.EdgeShader2={uniforms:{tDiffuse:{type:"t",value:null},aspect:{type:"v2",value:new THREE.Vector2(512,512)}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:["uniform sampler2D tDiffuse;","varying vec2 vUv;","uniform vec2 aspect;","vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);","mat3 G[2];","const mat3 g0 = mat3( 1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0 );","const mat3 g1 = mat3( 1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0 );","void main(void)","{","mat3 I;","float cnv[2];","vec3 sample;","G[0] = g0;","G[1] = g1;","for (float i=0.0; i<3.0; i++)","for (float j=0.0; j<3.0; j++) {","sample = texture2D( tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;","I[int(i)][int(j)] = length(sample);","}","for (int i=0; i<2; i++) {","float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);","cnv[i] = dp3 * dp3; ","}","gl_FragColor = vec4(0.5 * sqrt(cnv[0]*cnv[0]+cnv[1]*cnv[1]));","} ",].join("\n")};THREE.EffectComposer=function(n,t){if(this.renderer=n,t===undefined){var i=window.innerWidth||1,r=window.innerHeight||1,u={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat,stencilBuffer:!1};t=new THREE.WebGLRenderTarget(i,r,u)}this.renderTarget1=t;this.renderTarget2=t.clone();this.writeBuffer=this.renderTarget1;this.readBuffer=this.renderTarget2;this.passes=[];THREE.CopyShader===undefined&&console.error("THREE.EffectComposer relies on THREE.CopyShader");this.copyPass=new THREE.ShaderPass(THREE.CopyShader)};THREE.EffectComposer.prototype={swapBuffers:function(){var n=this.readBuffer;this.readBuffer=this.writeBuffer;this.writeBuffer=n},addPass:function(n){this.passes.push(n)},insertPass:function(n,t){this.passes.splice(t,0,n)},render:function(n){var i,t,u,f,r;for(this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,i=!1,f=this.passes.length,u=0;u<f;u++)(t=this.passes[u],t.enabled)&&(t.render(this.renderer,this.writeBuffer,this.readBuffer,n,i),t.needsSwap&&(i&&(r=this.renderer.context,r.stencilFunc(r.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,n),r.stencilFunc(r.EQUAL,1,4294967295)),this.swapBuffers()),t instanceof THREE.MaskPass?i=!0:t instanceof THREE.ClearMaskPass&&(i=!1))},reset:function(n){n===undefined&&(n=this.renderTarget1.clone(),n.width=window.innerWidth,n.height=window.innerHeight);this.renderTarget1=n;this.renderTarget2=n.clone();this.writeBuffer=this.renderTarget1;this.readBuffer=this.renderTarget2},setSize:function(n,t){var i=this.renderTarget1.clone();i.width=n;i.height=t;this.reset(i)}};THREE.FilmPass=function(n,t,i,r){THREE.FilmShader===undefined&&console.error("THREE.FilmPass relies on THREE.FilmShader");var u=THREE.FilmShader;this.uniforms=THREE.UniformsUtils.clone(u.uniforms);this.material=new THREE.ShaderMaterial({uniforms:this.uniforms,vertexShader:u.vertexShader,fragmentShader:u.fragmentShader});r!==undefined&&(this.uniforms.grayscale.value=r);n!==undefined&&(this.uniforms.nIntensity.value=n);t!==undefined&&(this.uniforms.sIntensity.value=t);i!==undefined&&(this.uniforms.sCount.value=i);this.enabled=!0;this.renderToScreen=!1;this.needsSwap=!0;this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1);this.scene=new THREE.Scene;this.quad=new THREE.Mesh(new THREE.PlaneGeometry(2,2),null);this.scene.add(this.quad)};THREE.FilmPass.prototype={render:function(n,t,i,r){this.uniforms.tDiffuse.value=i;this.uniforms.time.value+=r;this.quad.material=this.material;this.renderToScreen?n.render(this.scene,this.camera):n.render(this.scene,this.camera,t,!1)}};THREE.FilmShader={uniforms:{tDiffuse:{type:"t",value:null},time:{type:"f",value:0},nIntensity:{type:"f",value:.5},sIntensity:{type:"f",value:.05},sCount:{type:"f",value:4096},grayscale:{type:"i",value:1}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float time;\nuniform bool grayscale;\nuniform float nIntensity;\nuniform float sIntensity;\nuniform float sCount;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 cTextureScreen = texture2D( tDiffuse, vUv );\nfloat x = vUv.x * vUv.y * time *  1000.0;\nx = mod( x, 13.0 ) * mod( x, 123.0 );\nfloat dx = mod( x, 0.01 );\nvec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx * 100.0, 0.0, 1.0 );\nvec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\ncResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\ncResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\nif( grayscale ) {\ncResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\n}\ngl_FragColor =  vec4( cResult, cTextureScreen.a );\n}"};THREE.FocusShader={uniforms:{tDiffuse:{type:"t",value:null},screenWidth:{type:"f",value:1024},screenHeight:{type:"f",value:1024},sampleDistance:{type:"f",value:.94},waveFactor:{type:"f",value:.00125}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float screenWidth;\nuniform float screenHeight;\nuniform float sampleDistance;\nuniform float waveFactor;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 color, org, tmp, add;\nfloat sample_dist, f;\nvec2 vin;\nvec2 uv = vUv;\nadd = color = org = texture2D( tDiffuse, uv );\nvin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );\nsample_dist = dot( vin, vin ) * 2.0;\nf = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;\nvec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );\nadd += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );\nif( tmp.b < color.b ) color = tmp;\nadd += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );\nif( tmp.b < color.b ) color = tmp;\nadd += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );\nif( tmp.b < color.b ) color = tmp;\nadd += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );\nif( tmp.b < color.b ) color = tmp;\nadd += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );\nif( tmp.b < color.b ) color = tmp;\nadd += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );\nif( tmp.b < color.b ) color = tmp;\nadd += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );\nif( tmp.b < color.b ) color = tmp;\ncolor = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );\ncolor = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );\ngl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );\n}"};THREE.FresnelShader={uniforms:{mRefractionRatio:{type:"f",value:1.02},mFresnelBias:{type:"f",value:.1},mFresnelPower:{type:"f",value:2},mFresnelScale:{type:"f",value:1},tCube:{type:"t",value:null}},vertexShader:"uniform float mRefractionRatio;\nuniform float mFresnelBias;\nuniform float mFresnelScale;\nuniform float mFresnelPower;\nvarying vec3 vReflect;\nvarying vec3 vRefract[3];\nvarying float vReflectionFactor;\nvoid main() {\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\nvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\nvec3 I = worldPosition.xyz - cameraPosition;\nvReflect = reflect( I, worldNormal );\nvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );\nvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\nvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\nvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\ngl_Position = projectionMatrix * mvPosition;\n}",fragmentShader:"uniform samplerCube tCube;\nvarying vec3 vReflect;\nvarying vec3 vRefract[3];\nvarying float vReflectionFactor;\nvoid main() {\nvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\nvec4 refractedColor = vec4( 1.0 );\nrefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\nrefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\nrefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\ngl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\n}"};THREE.FXAAShader={uniforms:{tDiffuse:{type:"t",value:null},resolution:{type:"v2",value:new THREE.Vector2(1/1024,1/512)}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvarying vec2 vUv;\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_REDUCE_MUL   (1.0/8.0)\n#define FXAA_SPAN_MAX     8.0\nvoid main() {\nvec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;\nvec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;\nvec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;\nvec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;\nvec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );\nvec3 rgbM  = rgbaM.xyz;\nfloat opacity  = rgbaM.w;\nvec3 luma = vec3( 0.299, 0.587, 0.114 );\nfloat lumaNW = dot( rgbNW, luma );\nfloat lumaNE = dot( rgbNE, luma );\nfloat lumaSW = dot( rgbSW, luma );\nfloat lumaSE = dot( rgbSE, luma );\nfloat lumaM  = dot( rgbM,  luma );\nfloat lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );\nfloat lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );\nvec2 dir;\ndir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\ndir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\nfloat dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );\nfloat rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );\ndir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\nmax( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\ndir * rcpDirMin)) * resolution;\nvec3 rgbA = texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz;\nrgbA += texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz;\nrgbA *= 0.5;\nvec3 rgbB = texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * -0.5 ).xyz;\nrgbB += texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * 0.5 ).xyz;\nrgbB *= 0.25;\nrgbB += rgbA * 0.5;\nfloat lumaB = dot( rgbB, luma );\nif ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {\ngl_FragColor = vec4( rgbA, opacity );\n} else {\ngl_FragColor = vec4( rgbB, opacity );\n}\n}"};THREE.HorizontalBlurShader={uniforms:{tDiffuse:{type:"t",value:null},h:{type:"f",value:1/512}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse;\nuniform float h;\nvarying vec2 vUv;\nvoid main() {\nvec4 sum = vec4( 0.0 );\nsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\nsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\nsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\nsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\nsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\nsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\nsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\nsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\ngl_FragColor = sum;\n}"};THREE.HorizontalTiltShiftShader={uniforms:{tDiffuse:{type:"t",value:null},h:{type:"f",value:1/512},r:{type:"f",value:.35}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse;\nuniform float h;\nuniform float r;\nvarying vec2 vUv;\nvoid main() {\nvec4 sum = vec4( 0.0 );\nfloat hh = h * abs( r - vUv.y );\nsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;\nsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;\nsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;\nsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\nsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;\nsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;\nsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;\nsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;\ngl_FragColor = sum;\n}"};THREE.HueSaturationShader={uniforms:{tDiffuse:{type:"t",value:null},hue:{type:"f",value:0},saturation:{type:"f",value:0}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse;\nuniform float hue;\nuniform float saturation;\nvarying vec2 vUv;\nvoid main() {\ngl_FragColor = texture2D( tDiffuse, vUv );\nfloat angle = hue * 3.14159265;\nfloat s = sin(angle), c = cos(angle);\nvec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\nfloat len = length(gl_FragColor.rgb);\ngl_FragColor.rgb = vec3(\ndot(gl_FragColor.rgb, weights.xyz),\ndot(gl_FragColor.rgb, weights.zxy),\ndot(gl_FragColor.rgb, weights.yzx)\n);\nfloat average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\nif (saturation > 0.0) {\ngl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));\n} else {\ngl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);\n}\n}"};THREE.KaleidoShader={uniforms:{tDiffuse:{type:"t",value:null},sides:{type:"f",value:6},angle:{type:"f",value:0}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse;\nuniform float sides;\nuniform float angle;\nvarying vec2 vUv;\nvoid main() {\nvec2 p = vUv - 0.5;\nfloat r = length(p);\nfloat a = atan(p.y, p.x) + angle;\nfloat tau = 2. * 3.1416 ;\na = mod(a, tau/sides);\na = abs(a - tau/sides/2.) ;\np = r * vec2(cos(a), sin(a));\nvec4 color = texture2D(tDiffuse, p + 0.5);\ngl_FragColor = color;\n}"};THREE.LuminosityShader={uniforms:{tDiffuse:{type:"t",value:null}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D( tDiffuse, vUv );\nvec3 luma = vec3( 0.299, 0.587, 0.114 );\nfloat v = dot( texel.xyz, luma );\ngl_FragColor = vec4( v, v, v, texel.w );\n}"};THREE.MaskPass=function(n,t){this.scene=n;this.camera=t;this.enabled=!0;this.clear=!0;this.needsSwap=!1;this.inverse=!1};THREE.MaskPass.prototype={render:function(n,t,i){var r=n.context,u,f;r.colorMask(!1,!1,!1,!1);r.depthMask(!1);this.inverse?(u=0,f=1):(u=1,f=0);r.enable(r.STENCIL_TEST);r.stencilOp(r.REPLACE,r.REPLACE,r.REPLACE);r.stencilFunc(r.ALWAYS,u,4294967295);r.clearStencil(f);n.render(this.scene,this.camera,i,this.clear);n.render(this.scene,this.camera,t,this.clear);r.colorMask(!0,!0,!0,!0);r.depthMask(!0);r.stencilFunc(r.EQUAL,1,4294967295);r.stencilOp(r.KEEP,r.KEEP,r.KEEP)}};THREE.ClearMaskPass=function(){this.enabled=!0};THREE.ClearMaskPass.prototype={render:function(n){var t=n.context;t.disable(t.STENCIL_TEST)}};THREE.MirrorShader={uniforms:{tDiffuse:{type:"t",value:null},side:{type:"i",value:1}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse;\nuniform int side;\nvarying vec2 vUv;\nvoid main() {\nvec2 p = vUv;\nif (side == 0){\nif (p.x > 0.5) p.x = 1.0 - p.x;\n}else if (side == 1){\nif (p.x < 0.5) p.x = 1.0 - p.x;\n}else if (side == 2){\nif (p.y < 0.5) p.y = 1.0 - p.y;\n}else if (side == 3){\nif (p.y > 0.5) p.y = 1.0 - p.y;\n} \nvec4 color = texture2D(tDiffuse, p);\ngl_FragColor = color;\n}"};THREE.NormalMapShader={uniforms:{heightMap:{type:"t",value:null},resolution:{type:"v2",value:new THREE.Vector2(512,512)},scale:{type:"v2",value:new THREE.Vector2(1,1)},height:{type:"f",value:.05}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float height;\nuniform vec2 resolution;\nuniform sampler2D heightMap;\nvarying vec2 vUv;\nvoid main() {\nfloat val = texture2D( heightMap, vUv ).x;\nfloat valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;\nfloat valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;\ngl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );\n}"};THREE.ShaderLib.ocean_sim_vertex={varying:{vUV:{type:"v2"}},vertexShader:"varying vec2 vUV;\nvoid main (void) {\nvUV = position.xy * 0.5 + 0.5;\ngl_Position = vec4(position, 1.0 );\n}"};THREE.ShaderLib.ocean_subtransform={uniforms:{u_input:{type:"t",value:null},u_transformSize:{type:"f",value:512},u_subtransformSize:{type:"f",value:250}},varying:{vUV:{type:"v2"}},fragmentShader:"precision highp float;\nconst float PI = 3.14159265359;\nuniform sampler2D u_input;\nuniform float u_transformSize;\nuniform float u_subtransformSize;\nvarying vec2 vUV;\nvec2 multiplyComplex (vec2 a, vec2 b) {\nreturn vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);\n}\nvoid main (void) {\n#ifdef HORIZONTAL\nfloat index = vUV.x * u_transformSize - 0.5;\n#else\nfloat index = vUV.y * u_transformSize - 0.5;\n#endif\nfloat evenIndex = floor(index / u_subtransformSize) * (u_subtransformSize * 0.5) + mod(index, u_subtransformSize * 0.5);\n#ifdef HORIZONTAL\nvec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / u_transformSize).rgba;\nvec4 odd = texture2D(u_input, vec2(evenIndex + u_transformSize * 0.5 + 0.5, gl_FragCoord.y) / u_transformSize).rgba;\n#else\nvec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / u_transformSize).rgba;\nvec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + u_transformSize * 0.5 + 0.5) / u_transformSize).rgba;\n#endif\nfloat twiddleArgument = -2.0 * PI * (index / u_subtransformSize);\nvec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));\nvec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);\nvec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);\ngl_FragColor = vec4(outputA, outputB);\n}"};THREE.ShaderLib.ocean_initial_spectrum={uniforms:{u_wind:{type:"v2",value:new THREE.Vector2(10,10)},u_resolution:{type:"f",value:512},u_size:{type:"f",value:250}},fragmentShader:"precision highp float;\nconst float PI = 3.14159265359;\nconst float G = 9.81;\nconst float KM = 370.0;\nconst float CM = 0.23;\nuniform vec2 u_wind;\nuniform float u_resolution;\nuniform float u_size;\nfloat square (float x) {\nreturn x * x;\n}\nfloat omega (float k) {\nreturn sqrt(G * k * (1.0 + square(k / KM)));\n}\nfloat tanh (float x) {\nreturn (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));\n}\nvoid main (void) {\nvec2 coordinates = gl_FragCoord.xy - 0.5;\nfloat n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;\nfloat m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;\nvec2 K = (2.0 * PI * vec2(n, m)) / u_size;\nfloat k = length(K);\nfloat l_wind = length(u_wind);\nfloat Omega = 0.84;\nfloat kp = G * square(Omega / l_wind);\nfloat c = omega(k) / k;\nfloat cp = omega(kp) / kp;\nfloat Lpm = exp(-1.25 * square(kp / k));\nfloat gamma = 1.7;\nfloat sigma = 0.08 * (1.0 + 4.0 * pow(Omega, -3.0));\nfloat Gamma = exp(-square(sqrt(k / kp) - 1.0) / 2.0 * square(sigma));\nfloat Jp = pow(gamma, Gamma);\nfloat Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));\nfloat alphap = 0.006 * sqrt(Omega);\nfloat Bl = 0.5 * alphap * cp / c * Fp;\nfloat z0 = 0.000037 * square(l_wind) / G * pow(l_wind / cp, 0.9);\nfloat uStar = 0.41 * l_wind / log(10.0 / z0);\nfloat alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));\nfloat Fm = exp(-0.25 * square(k / KM - 1.0));\nfloat Bh = 0.5 * alpham * CM / c * Fm * Lpm;\nfloat a0 = log(2.0) / 4.0;\nfloat am = 0.13 * uStar / CM;\nfloat Delta = tanh(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));\nfloat cosPhi = dot(normalize(u_wind), normalize(K));\nfloat S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));\nfloat dk = 2.0 * PI / u_size;\nfloat h = sqrt(S / 2.0) * dk;\nif (K.x == 0.0 && K.y == 0.0) {\nh = 0.0;\n}\ngl_FragColor = vec4(h, 0.0, 0.0, 0.0);\n}"};THREE.ShaderLib.ocean_phase={uniforms:{u_phases:{type:"t",value:null},u_deltaTime:{type:"f",value:null},u_resolution:{type:"f",value:null},u_size:{type:"f",value:null}},varying:{vUV:{type:"v2"}},fragmentShader:"precision highp float;\nconst float PI = 3.14159265359;\nconst float G = 9.81;\nconst float KM = 370.0;\nvarying vec2 vUV;\nuniform sampler2D u_phases;\nuniform float u_deltaTime;\nuniform float u_resolution;\nuniform float u_size;\nfloat omega (float k) {\nreturn sqrt(G * k * (1.0 + k * k / KM * KM));\n}\nvoid main (void) {\nfloat deltaTime = 1.0 / 60.0;\nvec2 coordinates = gl_FragCoord.xy - 0.5;\nfloat n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;\nfloat m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;\nvec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;\nfloat phase = texture2D(u_phases, vUV).r;\nfloat deltaPhase = omega(length(waveVector)) * u_deltaTime;\nphase = mod(phase + deltaPhase, 2.0 * PI);\ngl_FragColor = vec4(phase, 0.0, 0.0, 0.0);\n}"};THREE.ShaderLib.ocean_spectrum={uniforms:{u_size:{type:"f",value:null},u_resolution:{type:"f",value:null},u_choppiness:{type:"f",value:null},u_phases:{type:"t",value:null},u_initialSpectrum:{type:"t",value:null}},varying:{vUV:{type:"v2"}},fragmentShader:"precision highp float;\nconst float PI = 3.14159265359;\nconst float G = 9.81;\nconst float KM = 370.0;\nvarying vec2 vUV;\nuniform float u_size;\nuniform float u_resolution;\nuniform float u_choppiness;\nuniform sampler2D u_phases;\nuniform sampler2D u_initialSpectrum;\nvec2 multiplyComplex (vec2 a, vec2 b) {\nreturn vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);\n}\nvec2 multiplyByI (vec2 z) {\nreturn vec2(-z[1], z[0]);\n}\nfloat omega (float k) {\nreturn sqrt(G * k * (1.0 + k * k / KM * KM));\n}\nvoid main (void) {\nvec2 coordinates = gl_FragCoord.xy - 0.5;\nfloat n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;\nfloat m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;\nvec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;\nfloat phase = texture2D(u_phases, vUV).r;\nvec2 phaseVector = vec2(cos(phase), sin(phase));\nvec2 h0 = texture2D(u_initialSpectrum, vUV).rg;\nvec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - vUV + 1.0 / u_resolution)).rg;\nh0Star.y *= -1.0;\nvec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));\nvec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;\nvec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;\nif (waveVector.x == 0.0 && waveVector.y == 0.0) {\nh = vec2(0.0);\nhX = vec2(0.0);\nhZ = vec2(0.0);\n}\ngl_FragColor = vec4(hX + multiplyByI(h), hZ);\n}"};THREE.ShaderLib.ocean_normals={uniforms:{u_displacementMap:{type:"t",value:null},u_resolution:{type:"f",value:null},u_size:{type:"f",value:null}},varying:{vUV:{type:"v2"}},fragmentShader:"precision highp float;\nvarying vec2 vUV;\nuniform sampler2D u_displacementMap;\nuniform float u_resolution;\nuniform float u_size;\nvoid main (void) {\nfloat texel = 1.0 / u_resolution;\nfloat texelSize = u_size / u_resolution;\nvec3 center = texture2D(u_displacementMap, vUV).rgb;\nvec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(texel, 0.0)).rgb - center;\nvec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(-texel, 0.0)).rgb - center;\nvec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, -texel)).rgb - center;\nvec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, texel)).rgb - center;\nvec3 topRight = cross(right, top);\nvec3 topLeft = cross(top, left);\nvec3 bottomLeft = cross(left, bottom);\nvec3 bottomRight = cross(bottom, right);\ngl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);\n}"};THREE.ShaderLib.ocean_main={uniforms:{u_displacementMap:{type:"t",value:null},u_normalMap:{type:"t",value:null},u_geometrySize:{type:"f",value:null},u_size:{type:"f",value:null},u_projectionMatrix:{type:"m4",value:null},u_viewMatrix:{type:"m4",value:null},u_cameraPosition:{type:"v3",value:null},u_skyColor:{type:"v3",value:null},u_oceanColor:{type:"v3",value:null},u_sunDirection:{type:"v3",value:null},u_exposure:{type:"f",value:null}},varying:{vPos:{type:"v3"},vUV:{type:"v2"}},vertexShader:"precision highp float;\nvarying vec3 vPos;\nvarying vec2 vUV;\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_viewMatrix;\nuniform float u_size;\nuniform float u_geometrySize;\nuniform sampler2D u_displacementMap;\nvoid main (void) {\nvec3 newPos = position + texture2D(u_displacementMap, uv).rgb * (u_geometrySize / u_size);\nvPos = newPos;\nvUV = uv;\ngl_Position = u_projectionMatrix * u_viewMatrix * vec4(newPos, 1.0);\n}",fragmentShader:"precision highp float;\nvarying vec3 vPos;\nvarying vec2 vUV;\nuniform sampler2D u_displacementMap;\nuniform sampler2D u_normalMap;\nuniform vec3 u_cameraPosition;\nuniform vec3 u_oceanColor;\nuniform vec3 u_skyColor;\nuniform vec3 u_sunDirection;\nuniform float u_exposure;\nvec3 hdr (vec3 color, float exposure) {\nreturn 1.0 - exp(-color * exposure);\n}\nvoid main (void) {\nvec3 normal = texture2D(u_normalMap, vUV).rgb;\nvec3 view = normalize(u_cameraPosition - vPos);\nfloat fresnel = 0.02 + 0.98 * pow(1.0 - dot(normal, view), 5.0);\nvec3 sky = fresnel * u_skyColor;\nfloat diffuse = clamp(dot(normal, normalize(u_sunDirection)), 0.0, 1.0);\nvec3 water = (1.0 - fresnel) * u_oceanColor * u_skyColor * diffuse;\nvec3 color = sky + water;\ngl_FragColor = vec4(hdr(color, u_exposure), 1.0);\n}"};THREE.RenderPass=function(n,t,i,r,u){this.scene=n;this.camera=t;this.overrideMaterial=i;this.clearColor=r;this.clearAlpha=u!==undefined?u:1;this.oldClearColor=new THREE.Color;this.oldClearAlpha=1;this.enabled=!0;this.clear=!0;this.needsSwap=!1};THREE.RenderPass.prototype={render:function(n,t,i){this.scene.overrideMaterial=this.overrideMaterial;this.clearColor&&(this.oldClearColor.copy(n.getClearColor()),this.oldClearAlpha=n.getClearAlpha(),n.setClearColor(this.clearColor,this.clearAlpha));n.render(this.scene,this.camera,i,this.clear);this.clearColor&&n.setClearColor(this.oldClearColor,this.oldClearAlpha);this.scene.overrideMaterial=null}};THREE.RGBShiftShader={uniforms:{tDiffuse:{type:"t",value:null},amount:{type:"f",value:.005},angle:{type:"f",value:0}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse;\nuniform float amount;\nuniform float angle;\nvarying vec2 vUv;\nvoid main() {\nvec2 offset = amount * vec2( cos(angle), sin(angle));\nvec4 cr = texture2D(tDiffuse, vUv + offset);\nvec4 cga = texture2D(tDiffuse, vUv);\nvec4 cb = texture2D(tDiffuse, vUv - offset);\ngl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\n}"};THREE.SavePass=function(n){THREE.CopyShader===undefined&&console.error("THREE.SavePass relies on THREE.CopyShader");var t=THREE.CopyShader;this.textureID="tDiffuse";this.uniforms=THREE.UniformsUtils.clone(t.uniforms);this.material=new THREE.ShaderMaterial({uniforms:this.uniforms,vertexShader:t.vertexShader,fragmentShader:t.fragmentShader});this.renderTarget=n;this.renderTarget===undefined&&(this.renderTargetParameters={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat,stencilBuffer:!1},this.renderTarget=new THREE.WebGLRenderTarget(window.innerWidth,window.innerHeight,this.renderTargetParameters));this.enabled=!0;this.needsSwap=!1;this.clear=!1;this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1);this.scene=new THREE.Scene;this.quad=new THREE.Mesh(new THREE.PlaneGeometry(2,2),null);this.scene.add(this.quad)};THREE.SavePass.prototype={render:function(n,t,i){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=i);this.quad.material=this.material;n.render(this.scene,this.camera,this.renderTarget,this.clear)}};THREE.SepiaShader={uniforms:{tDiffuse:{type:"t",value:null},amount:{type:"f",value:1}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float amount;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 color = texture2D( tDiffuse, vUv );\nvec3 c = color.rgb;\ncolor.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );\ncolor.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );\ncolor.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );\ngl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );\n}"};THREE.ShaderPass=function(n,t){this.textureID=t!==undefined?t:"tDiffuse";this.uniforms=THREE.UniformsUtils.clone(n.uniforms);this.material=new THREE.ShaderMaterial({uniforms:this.uniforms,vertexShader:n.vertexShader,fragmentShader:n.fragmentShader});this.renderToScreen=!1;this.enabled=!0;this.needsSwap=!0;this.clear=!1;this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1);this.scene=new THREE.Scene;this.quad=new THREE.Mesh(new THREE.PlaneGeometry(2,2),null);this.scene.add(this.quad)};THREE.ShaderPass.prototype={render:function(n,t,i){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=i);this.quad.material=this.material;this.renderToScreen?n.render(this.scene,this.camera):n.render(this.scene,this.camera,t,this.clear)}};THREE.SSAOShader={uniforms:{tDiffuse:{type:"t",value:null},tDepth:{type:"t",value:null},size:{type:"v2",value:new THREE.Vector2(512,512)},cameraNear:{type:"f",value:1},cameraFar:{type:"f",value:100},onlyAO:{type:"i",value:0},aoClamp:{type:"f",value:.5},lumInfluence:{type:"f",value:.5}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float cameraNear;\nuniform float cameraFar;\nuniform bool onlyAO;\nuniform vec2 size;\nuniform float aoClamp;\nuniform float lumInfluence;\nuniform sampler2D tDiffuse;\nuniform sampler2D tDepth;\nvarying vec2 vUv;\n#define DL 2.399963229728653\n#define EULER 2.718281828459045\nfloat width = size.x;\nfloat height = size.y;\nfloat cameraFarPlusNear = cameraFar + cameraNear;\nfloat cameraFarMinusNear = cameraFar - cameraNear;\nfloat cameraCoef = 2.0 * cameraNear;\nconst int samples = 8;\nconst float radius = 5.0;\nconst bool useNoise = false;\nconst float noiseAmount = 0.0003;\nconst float diffArea = 0.4;\nconst float gDisplace = 0.4;\nfloat unpackDepth( const in vec4 rgba_depth ) {\nconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\nfloat depth = dot( rgba_depth, bit_shift );\nreturn depth;\n}\nvec2 rand( const vec2 coord ) {\nvec2 noise;\nif ( useNoise ) {\nfloat nx = dot ( coord, vec2( 12.9898, 78.233 ) );\nfloat ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );\nnoise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );\n} else {\nfloat ff = fract( 1.0 - coord.s * ( width / 2.0 ) );\nfloat gg = fract( coord.t * ( height / 2.0 ) );\nnoise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;\n}\nreturn ( noise * 2.0  - 1.0 ) * noiseAmount;\n}\nfloat readDepth( const in vec2 coord ) {\nreturn cameraCoef / ( cameraFarPlusNear - unpackDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );\n}\nfloat compareDepths( const in float depth1, const in float depth2, inout int far ) {\nfloat garea = 2.0;\nfloat diff = ( depth1 - depth2 ) * 100.0;\nif ( diff < gDisplace ) {\ngarea = diffArea;\n} else {\nfar = 1;\n}\nfloat dd = diff - gDisplace;\nfloat gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );\nreturn gauss;\n}\nfloat calcAO( float depth, float dw, float dh ) {\nfloat dd = radius - depth * radius;\nvec2 vv = vec2( dw, dh );\nvec2 coord1 = vUv + dd * vv;\nvec2 coord2 = vUv - dd * vv;\nfloat temp1 = 0.0;\nfloat temp2 = 0.0;\nint far = 0;\ntemp1 = compareDepths( depth, readDepth( coord1 ), far );\nif ( far > 0 ) {\ntemp2 = compareDepths( readDepth( coord2 ), depth, far );\ntemp1 += ( 1.0 - temp1 ) * temp2;\n}\nreturn temp1;\n}\nvoid main() {\nvec2 noise = rand( vUv );\nfloat depth = readDepth( vUv );\nfloat tt = clamp( depth, aoClamp, 1.0 );\nfloat w = ( 1.0 / width )  / tt + ( noise.x * ( 1.0 - noise.x ) );\nfloat h = ( 1.0 / height ) / tt + ( noise.y * ( 1.0 - noise.y ) );\nfloat ao = 0.0;\nfloat dz = 1.0 / float( samples );\nfloat z = 1.0 - dz / 2.0;\nfloat l = 0.0;\nfor ( int i = 0; i <= samples; i ++ ) {\nfloat r = sqrt( 1.0 - z );\nfloat pw = cos( l ) * r;\nfloat ph = sin( l ) * r;\nao += calcAO( depth, pw * w, ph * h );\nz = z - dz;\nl = l + DL;\n}\nao /= float( samples );\nao = 1.0 - ao;\nvec3 color = texture2D( tDiffuse, vUv ).rgb;\nvec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );\nfloat lum = dot( color.rgb, lumcoeff );\nvec3 luminance = vec3( lum );\nvec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\nif ( onlyAO ) {\nfinal = vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\n}\ngl_FragColor = vec4( final, 1.0 );\n}"};THREE.TexturePass=function(n,t){THREE.CopyShader===undefined&&console.error("THREE.TexturePass relies on THREE.CopyShader");var i=THREE.CopyShader;this.uniforms=THREE.UniformsUtils.clone(i.uniforms);this.uniforms.opacity.value=t!==undefined?t:1;this.uniforms.tDiffuse.value=n;this.material=new THREE.ShaderMaterial({uniforms:this.uniforms,vertexShader:i.vertexShader,fragmentShader:i.fragmentShader});this.enabled=!0;this.needsSwap=!1;this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1);this.scene=new THREE.Scene;this.quad=new THREE.Mesh(new THREE.PlaneGeometry(2,2),null);this.scene.add(this.quad)};THREE.TexturePass.prototype={render:function(n,t,i){this.quad.material=this.material;n.render(this.scene,this.camera,i)}};THREE.TriangleBlurShader={uniforms:{texture:{type:"t",value:null},delta:{type:"v2",value:new THREE.Vector2(1,1)}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"#define ITERATIONS 10.0\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 vUv;\nfloat random( vec3 scale, float seed ) {\nreturn fract( sin( dot( gl_FragCoord.xyz + seed, scale ) ) * 43758.5453 + seed );\n}\nvoid main() {\nvec4 color = vec4( 0.0 );\nfloat total = 0.0;\nfloat offset = random( vec3( 12.9898, 78.233, 151.7182 ), 0.0 );\nfor ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {\nfloat percent = ( t + offset - 0.5 ) / ITERATIONS;\nfloat weight = 1.0 - abs( percent );\ncolor += texture2D( texture, vUv + delta * percent ) * weight;\ntotal += weight;\n}\ngl_FragColor = color / total;\n}"};THREE.UnpackDepthRGBAShader={uniforms:{tDiffuse:{type:"t",value:null},opacity:{type:"f",value:1}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float opacity;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nfloat unpackDepth( const in vec4 rgba_depth ) {\nconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\nfloat depth = dot( rgba_depth, bit_shift );\nreturn depth;\n}\nvoid main() {\nfloat depth = 1.0 - unpackDepth( texture2D( tDiffuse, vUv ) );\ngl_FragColor = opacity * vec4( vec3( depth ), 1.0 );\n}"};THREE.VerticalBlurShader={uniforms:{tDiffuse:{type:"t",value:null},v:{type:"f",value:1/512}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse;\nuniform float v;\nvarying vec2 vUv;\nvoid main() {\nvec4 sum = vec4( 0.0 );\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\ngl_FragColor = sum;\n}"};THREE.VerticalTiltShiftShader={uniforms:{tDiffuse:{type:"t",value:null},v:{type:"f",value:1/512},r:{type:"f",value:.35}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse;\nuniform float v;\nuniform float r;\nvarying vec2 vUv;\nvoid main() {\nvec4 sum = vec4( 0.0 );\nfloat vv = v * abs( r - vUv.y );\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;\nsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;\ngl_FragColor = sum;\n}"};THREE.VignetteShader={uniforms:{tDiffuse:{type:"t",value:null},offset:{type:"f",value:1},darkness:{type:"f",value:1}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float offset;\nuniform float darkness;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D( tDiffuse, vUv );\nvec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );\ngl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );\n}"};